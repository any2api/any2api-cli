#!/usr/bin/env node
'use strict';

var app = require('commander');
var fs = require('fs-extra');
var path = require('path');
var url = require('url');
var async = require('async');
var _ = require('lodash');
_.str = require('underscore.string');

var util = require('any2api-util');
var reg = require('any2api-reg');

var specFile = 'apispec.json';
var defaultOutput = '.';
var scannerPrefix = 'any2api-scanner-';

var defaultModules = {
  scanner: [ 'any2api-scanner-chef', 'any2api-scanner-juju' ],
  invoker: [ 'any2api-invoker-chef' ],
  generator: [ 'any2api-generator-rest' ]
};



var basePath = process.env.ANY2API_PATH;

if (!basePath) {
  basePath = process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE;

  if (!basePath) {
    return console.error('ANY2API_PATH environment variable missing');
  } else {
    basePath = path.join(basePath, '.any2api');
  }
}



app.version(require('../package.json').version)
  .option('-o, --output <dir>', 'set output directory (default: \'.\')', defaultOutput)
  .option('-S, --scanner <name>', 'select scanner to analyze executable')
  .option('-r, --retrieve <name>', 'select retrieve protocol to download files (default: \'http\')')
  .option('-s, --subdir <dir>', 'set subdir (rel. to output) of executable ' +
            '(default: \'executable\')', 'executable')
  .option('-c, --copy-executable', 'copy executable to output directory (disabled by default)')
  .option('-G, --generator <name>', 'select generator to create API implementation')
  .option('-p, --prepare-executable', 'prepare executable at buildtime (disabled by default)')
  .option('-i, --interface <name>', 'select type of interface (default: \'rest\')', 'rest')
  .option('-t, --impl-type <name>', 'select type of API implementation (default: \'node\')', 'node');

app.command('install <type> <modules...>')
  .description('install given modules (name, dir, or URL)')
  .action(function(type, modules) {
    if (_.contains(modules, 'all')) {
      modules = _.filter(modules, function(module) {
        if (module === 'all') return false;
        else return true;
      });

      modules = modules.concat(defaultModules[type]);
    }

    modules = _.uniq(modules);

    var install;

    if (type === 'scanner') {
      install = reg.Scanners({ path: basePath }).install;
    } else if (type === 'invoker') {
      install = reg.Invokers({ path: basePath }).install;
    } else if (type === 'generator') {
      install = reg.Generators({ path: basePath }).install;
    } else {
      return console.error('unknown module type:', type);
    }

    async.eachSeries(modules, install, function(err) {
      if (err) throw err;
    });
  });

app.command('uninstall <type> <modules...>')
  .description('uninstall given modules (name)')
  .action(function(type, modules) {
    modules = _.uniq(modules);

    console.error('not implemented yet');

    //TODO: reg.uninstall() ...
  });

app.command('scan <executable>')
  .description('scan given executable (file, dir, or URL) and create API spec')
  .action(function(exec) {
    var output = path.resolve(app.output);

    var scanners = reg.Scanners({ path: basePath });

    //TODO: maybe move some of the logic from here to any2api-reg/Scanners
    if (app.scanner && !scanners.existsSync(app.scanner)) {
      app.scanner = scannerPrefix + app.scanner;

      if (!scanners.existsSync(app.scanner)) {
        throw new Error('scanner ' + app.scanner + ' missing');
      }
    }

    var execPath = output;

    if (app.subdir) execPath = path.join(output, app.subdir);

    fs.mkdirsSync(path.join(execPath, '..'));

    var specPath = path.join(output, specFile);

    var scan = function() {
      console.log('Scanning executable:', execPath);

      var basename = path.basename(exec, path.extname(exec));

      if (app.scanner) {
        scanners.get(app.scanner, function(err, Scanner) {
          if (err) throw err;

          Scanner().scan(execPath, writeSpec);
        });
      } else {
        scanners.scan(execPath, writeSpec);
      }
    }

    var writeSpec = function(err, apiSpec) {
      console.log('Executable scanned.');

      if (err) throw err;
      else if (_.isEmpty(apiSpec)) throw new Error('API spec is empty, most probably no scanner available');

      console.log('Writing API spec:', specPath);

      apiSpec.executable.path = path.relative(output, execPath);
      if (_.str.startsWith(apiSpec.executable.path, '..')) apiSpec.executable.path = execPath;
      else if (_.isEmpty(apiSpec.executable.path)) apiSpec.executable.path = '.';

      fs.writeFileSync(specPath, JSON.stringify(apiSpec, null, 2));

      console.log('API spec written.');
    }

    var storeExecCallback = function(err) {
      if (err) throw err;

      console.log('Executable stored:', execPath);

      scan();
    };

    if (!app.retriever &&
        (_.str.startsWith(exec, 'http://') || _.str.startsWith(exec, 'https://'))) {
      app.retriever = 'http';
    } else if (!app.retriever && _.str.startsWith(exec, 'lp:')) {
      app.retriever = 'bzr';
    }

    if (app.retriever) {
      console.log('Retrieving executable:', exec);

      var execUrl = exec;
      exec = _.last(url.parse(execUrl).pathname.replace(/\/$/, '').split('/'));

      if (app.retriever === 'http' || app.retriever === 'https') {
        util.download({ url: execUrl, dir: execPath }, storeExecCallback);
      } else if (app.retriever === 'git') {
        util.checkoutGit({ url: execUrl, dir: execPath }, storeExecCallback);
      } else if (app.retriever === 'bzr' || app.retriever === 'bazaar') {
        util.checkoutBzr({ url: execUrl, dir: execPath }, storeExecCallback);
      } else {
        throw new Error('retriever ' + app.retriever + ' missing');
      }
    } else if (!fs.existsSync(exec)) {
      throw new Error('executable ' + exec + ' missing');
    } else if (fs.statSync(exec).isFile()) {
      console.log('Extracting executable:', exec);

      util.extract({ file: exec, dir: execPath }, storeExecCallback);
    } else if (fs.statSync(exec).isDirectory()) {
      if (path.resolve(exec) !== path.resolve(execPath) && app.copyExecutable) {
        console.log('Copying executable:', exec);

        fs.mkdirsSync(execPath);
        fs.copySync(exec, execPath);

        console.log('Executable stored:', execPath);
      } else if (path.resolve(output) === path.resolve(defaultOutput)) {
        output = exec;

        specPath = path.join(output, specFile);
      } else {
        execPath = exec;
      }

      scan();
    }
  });

app.command('gen <api-spec>')
  .description('generate API implementation based on given API spec (file or dir)')
  .action(function(specPath) {
    var output = path.resolve(app.output);

    if (fs.existsSync(output)) {
      throw new Error('output directory must not exist');
    }

    var invokers = reg.Invokers({ path: basePath });
    var generators = reg.Generators({ path: basePath });

    var spec;

    //TODO: respect app.generator if set

    var updateSpecCallback = function(callback) {
      return function(err, apiSpec) {
        if (err) return callback(err);

        if (apiSpec) {
          if (!apiSpec.apispec_path) {
            apiSpec.apispec_path = spec.apispec_path;
          }

          spec = apiSpec;
        }

        callback();
      };
    };

    async.series([
      function(callback) {
        util.readInput({ apispec_path: specPath }, updateSpecCallback(callback));
      },
      function(callback) {
        invokers.getInvokerPath(spec, callback);
      },
      function(callback) {
        spec.implementation.path = output;

        if (app.implType) spec.implementation.type = app.implType;

        if (app.interface) spec.implementation.interface = app.interface;

        generators.generate(spec, updateSpecCallback(callback));
      },
      function(callback) {
        //TODO: run this only if prepareExecutable has to run
        invokers.prepareBuildtime(spec, updateSpecCallback(callback));
      },
      function(callback) {
        //TODO: respect app.prepareExecutable (BOOLEAN) -> if FALSE: exec needs to be prepared at runtime
        invokers.prepareExecutable(spec, updateSpecCallback(callback));
      }
    ], function(err) {
      if (err) throw err;

      specPath = spec.apispec_path;
      delete spec.apispec_path;

      fs.writeFileSync(specPath, JSON.stringify(spec, null, 2));

      console.log('API implementation generated with API spec:', specPath);
    });
  });

app.command('test <api-impl>')
  .description('test given API implementation (dir)')
  .action(function(impl) {
    console.error('not implemented yet');

    //TODO: run npm test
  });

/*
app.command('*')
  .description('...')
  .action(function(cmd) {
    console.error('Command \'' + cmd + '\' not supported.');

    app.help();
  });
*/

app.parse(process.argv);



//TODO: print help if no command is given: app.help();
